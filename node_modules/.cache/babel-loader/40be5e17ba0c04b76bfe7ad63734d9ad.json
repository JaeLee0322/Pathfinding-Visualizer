{"ast":null,"code":"export function dfs(grid, height, width) {\n  const startNode = grid.findNode(grid.startNode.y, grid.startNode.x);\n  const finishNode = grid.findNode(grid.endNode.y, grid.endNode.x);\n  const visitedNodesInOrder = [];\n  let nextNodesStack = [];\n  nextNodesStack.push(startNode);\n\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.pop();\n    if (currentNode === finishNode) return visitedNodesInOrder;\n\n    if (!(currentNode.nodeType === 1) && (currentNode.nodeType === 2 || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const {\n        col,\n        row\n      } = currentNode;\n      let nextNode;\n\n      if (row > 0) {\n        nextNode = grid.squares[row - 1][col];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (row < height - 1) {\n        nextNode = grid.squares[row + 1][col];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col > 0) {\n        nextNode = grid.squares[row][col - 1];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col < width - 1) {\n        nextNode = grid.squares[row][col + 1];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}\nexport default dfs;","map":{"version":3,"names":["dfs","grid","height","width","startNode","findNode","y","x","finishNode","endNode","visitedNodesInOrder","nextNodesStack","push","length","currentNode","pop","nodeType","isVisited","col","row","nextNode","squares","previousNode"],"sources":["C:/Users/jaewh/OneDrive/Desktop/Resume/Pathfinding-Visualizer/src/algorithms/dfs.jsx"],"sourcesContent":["export function dfs(grid, height, width) {\r\n    const startNode = grid.findNode(grid.startNode.y, grid.startNode.x);\r\n    const finishNode = grid.findNode(grid.endNode.y, grid.endNode.x);\r\n\r\n    const visitedNodesInOrder = [];\r\n    let nextNodesStack = [];\r\n    nextNodesStack.push(startNode);\r\n    while (nextNodesStack.length) {\r\n        const currentNode = nextNodesStack.pop();\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n\r\n        if (\r\n            !(currentNode.nodeType === 1) &&\r\n            (currentNode.nodeType === 2 || !currentNode.isVisited)\r\n        ) {\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            const { col, row } = currentNode;\r\n            let nextNode;\r\n            if (row > 0) {\r\n                nextNode = grid.squares[row - 1][col];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (row < height - 1) {\r\n                nextNode = grid.squares[row + 1][col];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (col > 0) {\r\n                nextNode = grid.squares[row][col - 1];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n            if (col < width - 1) {\r\n                nextNode = grid.squares[row][col + 1];\r\n                if (!nextNode.isVisited) {\r\n                    nextNode.previousNode = currentNode;\r\n                    nextNodesStack.push(nextNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexport default dfs"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,MAAnB,EAA2BC,KAA3B,EAAkC;EACrC,MAAMC,SAAS,GAAGH,IAAI,CAACI,QAAL,CAAcJ,IAAI,CAACG,SAAL,CAAeE,CAA7B,EAAgCL,IAAI,CAACG,SAAL,CAAeG,CAA/C,CAAlB;EACA,MAAMC,UAAU,GAAGP,IAAI,CAACI,QAAL,CAAcJ,IAAI,CAACQ,OAAL,CAAaH,CAA3B,EAA8BL,IAAI,CAACQ,OAAL,CAAaF,CAA3C,CAAnB;EAEA,MAAMG,mBAAmB,GAAG,EAA5B;EACA,IAAIC,cAAc,GAAG,EAArB;EACAA,cAAc,CAACC,IAAf,CAAoBR,SAApB;;EACA,OAAOO,cAAc,CAACE,MAAtB,EAA8B;IAC1B,MAAMC,WAAW,GAAGH,cAAc,CAACI,GAAf,EAApB;IACA,IAAID,WAAW,KAAKN,UAApB,EAAgC,OAAOE,mBAAP;;IAEhC,IACI,EAAEI,WAAW,CAACE,QAAZ,KAAyB,CAA3B,MACCF,WAAW,CAACE,QAAZ,KAAyB,CAAzB,IAA8B,CAACF,WAAW,CAACG,SAD5C,CADJ,EAGE;MACEH,WAAW,CAACG,SAAZ,GAAwB,IAAxB;MACAP,mBAAmB,CAACE,IAApB,CAAyBE,WAAzB;MACA,MAAM;QAAEI,GAAF;QAAOC;MAAP,IAAeL,WAArB;MACA,IAAIM,QAAJ;;MACA,IAAID,GAAG,GAAG,CAAV,EAAa;QACTC,QAAQ,GAAGnB,IAAI,CAACoB,OAAL,CAAaF,GAAG,GAAG,CAAnB,EAAsBD,GAAtB,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACrBG,QAAQ,CAACE,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBQ,QAApB;QACH;MACJ;;MACD,IAAID,GAAG,GAAGjB,MAAM,GAAG,CAAnB,EAAsB;QAClBkB,QAAQ,GAAGnB,IAAI,CAACoB,OAAL,CAAaF,GAAG,GAAG,CAAnB,EAAsBD,GAAtB,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACrBG,QAAQ,CAACE,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBQ,QAApB;QACH;MACJ;;MACD,IAAIF,GAAG,GAAG,CAAV,EAAa;QACTE,QAAQ,GAAGnB,IAAI,CAACoB,OAAL,CAAaF,GAAb,EAAkBD,GAAG,GAAG,CAAxB,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACrBG,QAAQ,CAACE,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBQ,QAApB;QACH;MACJ;;MACD,IAAIF,GAAG,GAAGf,KAAK,GAAG,CAAlB,EAAqB;QACjBiB,QAAQ,GAAGnB,IAAI,CAACoB,OAAL,CAAaF,GAAb,EAAkBD,GAAG,GAAG,CAAxB,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACrBG,QAAQ,CAACE,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBQ,QAApB;QACH;MACJ;IACJ;EACJ;AACJ;AACD,eAAepB,GAAf"},"metadata":{},"sourceType":"module"}